\section{Introduction}
Multi-streamed SSDs provide a special mechanism,
called streams, for a host system to prevent data with different lifetimes 
from being mixed into the same block~\cite{MultiStream}.
Streams, when properly used, can significantly improve both the performance and lifetime of flash-based SSDs by reducing
the garbage collection overhead~\cite{MultiStream, FStream, AutoStream, Level}.  
In order to achieve high performance on multi-streamed SSDs, data with similar 
future update times~\cite{PCHa}
should be allocated to the same stream.
However, since it is difficult to know the future update times {\it a priori} when they are written,
many existing techniques make stream allocation decisions both {\it statically} and {\it manually} by relying on 
programmers' understanding on I/O characteristics of applications/file systems~\cite{MultiStream,FStream}.  
Our long-term goal is to develop a new stream allocation technique, 
which completely automates the task of stream allocation without any direct involvement from programmers.

In order to evaluate the existing stream allocation techniques, 
we view that at least three following  requirements should be satisfied 
by an ideal stream allocator {\sf IdealStream}.   
An ideal stream allocator {\sf IdealStream} needs to
meet at least three requirements.  
First, {\sf IdealStream} should be fully automatic without requiring manual work from
programmers.   
Second, {\sf IdealStream} must allocate streams based on the data lifetime.  
When two data have different lifetimes, they should not be allocated to the same stream.   
Third, {\sf IdealStream} should be able to change the data-to-stream mapping during the run time, 
reflecting varying data lifetimes.
As summarized in Table 1, however, none of existing stream management 
techniques~\cite{MultiStream,FStream,AutoStream} meets three requirements.  
Except for AutoStream~\cite{AutoStream}, 
both FStream~\cite{FStream} and ManualStream~\cite{MultiStream}
\footnote{For a description purpose, we call the technique 
used in~\cite{MultiStream} by ManualStream.}
are manual techniques 
which need to modify 
file system or applications.
Although AutoStream automatically allocates streams at the device driver level, 
its stream allocation policy does not work with modern append-only workloads such as RocksDB or Cassandra.  
Unlike conventional update workloads where data written to the same logical block address (LBA) 
shows a strong update locality, 
the recent append-only workload completely decouples the data lifetimes from LBAs.  
For example, as will be shown in Section 2, in RocksDB, 
a chunk of data written to a fixed 
LBA range have widely varying data lifetimes over times.  

\begin{table}[b]
	\vspace{-15pt}
	\centering
	\caption{Limitations of existing studies}
	\vspace{-5pt}
	\begin{tabular}{c|ccc}\hline
		\renewcommand{\arraystretch}{0.5}
		& lifetime- & \multirow{2}{*} {automatic} & \multirow{2}{*} {adaptable} \\
		 & based     &                           &                           \\ \hline\hline
		\renewcommand{\arraystretch}{0.5}
		Multi- &\multirow{2}{*}  o & \multirow{2}{*} x & \multirow{2}{*} x \\
		Streaming &                &                   &                   \\\hline
		\renewcommand{\arraystretch}{3}
		FStream & o & x & x \\ \hline
		\renewcommand{\arraystretch}{3}
		AutoStream & x & o & o \\ \hline
	\end{tabular}
\end{table}

In this paper, we propose a new stream management technique, called {\sf PCStream}, 
which meets all three requirements.   
The key insight behind {\sf PCStream} is that
data lifetimes should be monitored at a higher abstraction level than the LBA level.   
Since a program context represents a particular execution path of a program, 
when data lifetimes are observed at the same program context, 
they tend to be similar~\cite{PCHa}. 
For example, in the context of managing the RocksDB log file, 
log data are written when key-value pairs are temporarily stored in the memory, 
and log data are deleted if the key-value pairs are flushed to storage~\cite{RocksDB}.
In a typical workload, log data has a similar lifetime because the key-value pairs 
reside in the memory at a similar time.

By identifying program contexts during the run time, 
{\sf PCStream} can directly map a program context to a stream.   
While {\sf PCStream} works efficiently for most workloads, the lifetime of data written from
a single program context can be quite fluctuating, thus making a pure PC-based approach less effective.   
In {\sf PCStream}, we modify stream allocations when such PC is observed. 
The main drawback of the mixed lifetimes is that 
long-lived data remains as a valid page, worsening garbage collection efficiency.
In order to separate the long-lived data from the others,
we assign an additional stream, called substream, to copy valid pages
of the original stream.

Our experimental results show that {\sf PCStream} can reduce the
garbage collection overhead as much as manual stream
management techniques while no code modification is necessary.
For a RocksDB benchmark, {\sf PCStream} improved WAF by 40\% over 
the existing automatic technique.

The rest of this paper is organized as follows. 
We explain the key motivations behind {\sf PCStream} in Section 2. 
Section 3 describes the main modules of the {\sf PCStream} allocator.
The experimental results are shown in Section 4. 
Finally, we conclude in Section 5 with a summary and future works. 

\begin{comment}
...
Recent studies have used two strategies to utilize the stream feature.
One is to classify the application data into different streams based on an understanding
of the expected lifetime of those data~\cite{MultiStream},~\cite{FStream}. 
This manual stream assignment requires the programmer or system manager to 
fully understand the lifetime characteristics of the data, such as different levels
of a log-structured merge tree or the file extension of commitlog file.
Also when multiple applications try to assign streams, a centralized stream assignment
is required to avoid conflicts.
The other is to automate the process of mapping write I/O operations to an SSD stream~\cite{AutoStream}.
However, since AutoStream relies on the past LBA access patterns, 
it is not practical when the data are written in append-only manner, e.g. RocksDB or Cassandra.

Usually, the lifetime of data is determined by its purpose.
For example, files such as the write ahead log in RocksDB are quickly deleted, 
while write-once data is kept at the bottom level of the LSM-tree for a long time.
Our approach is motivated by the observation that the purpose of the application can be defined as
the execution path of function calls that lead to a write system call, called program context.
In this paper, we take the program context information as a lifetime hint for the automatic stream allocation. 
\end{comment}

