\vspace{-10pt}
\section{Experimental Results}
\vspace{-5pt}

For our experiments, we have implemented \textsf{PCStream} in the Linux kernel
4.5.  For objective evaluation, we compared \textsf{PCStream} with three
existing schemes: \textsf{Baseline}, \textsf{Manual}~\cite{MultiStream}, and
\textsf{AutoStream}~\cite{AutoStream}.  \textsf{Baseline} stands for a legacy
SSD that does not support a multi-stream feature. \textsf{Manual} is a RocksDB
implementation which is manually optimized for multi-streamed SSDs.
\textsf{AutoStream} is an LBA-based data separation technique which is
implemented at the block driver layer. To understand the impact of the
two-phase assignment, in addition, we compared \textsf{PCStream} with
\textsf{PCStream$^{*}$} which excluded the two-phase assignment feature.

For benchmarks, we have used three scenarios of \texttt{db\_bench} of RocksDB:
Update-Random (\texttt{UR}), Append-Random (\texttt{AR}), and Fill-Random
(\texttt{FR}) scenarios.  For key-value pairs already stored in the SSD,
\texttt{UR} updates values for random keys, creating many
read-modify-writes in the SSD.  \texttt{AR} is similar to \texttt{UR}, except
that it performs the update of values for growing keys. \texttt{FR} writes
key-value pairs to the SSD in a random key order.

\vspace{-10pt}
\subsection{Experiments with an SSD emulator}
%\vspace{-5pt}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\linewidth]{figure/result_emul}
	\vspace{-10pt}
%	\caption{The WAF comparison on the emulator.}
	\caption{A comparison of WAF on the SSD emulator.}
	\label{fig:result_emul}
	\vspace{-15pt}
\end{figure}

 \begin{figure}[b]
	\centering
	\vspace{-15pt}
	\includegraphics[width=1\linewidth]{figure/streamlifetime}
	\vspace{-20pt}
%	\caption{The WAF comparison on the emulator.}
	\caption{A lifetime comparison of each stream}
	\label{fig:streamlifetime}
\end{figure}

We carried out a set of experiments using an SSD emulator which is based on the
open flash development platform~\cite{AMF}.  The SSD emulator emulates the
behaviors of an SSD using host DRAM in the kernel level. Thus, it not only
allows us to easily add new features, but enables to analyze detailed internal
activities of an SSD.  We enhanced the original emulator so that it supported a
multi-streamed feature as well as the two-phase stream assignment.  The number
of streams supported by the emulator was 8.  The SSD emulator provided 12 GB
capacity with 4 channels and 4 ways, and there were 8192 flash blocks, each of
which was composed of 384 4-KB pages.  

We compared WAF of the existing techniques with {\sf PCStream} for the three
scenarios, and the result is shown in Fig.~\ref{fig:result_emul}.  As shown in
Fig.~\ref{fig:result_emul}, {\sf PCStream$^*$} reduced WAF by up to 30\% over
\textsf{AutoStream}.  The result shows that separating short-lived data (e.g.,
log and flush) from long-lived one (e.g., compaction) using PC was quite
effective in reducing WAF.  Moreover, {\sf PCStream} even showed similar WAF to
\textsf{Manual}, reducing it by up to 38\% over \textsf{AutoStream}.  This
additional benefit came from isolating long- and short-lived data in separate
blocks through the two-phase assignment at the SSD even if they belonged to the
same compaction PC.

<<<<<<< HEAD
%\textcolor{red}{(TODO: please add text for new exp here)}
=======
>>>>>>> 4b07409f4196627008e20e63972b6fd4735eadfd
In order to analyze the improvement made by {\sf PCStream}, 
we measured the data lifetime of each stream for the {\tt UR} scenario.
Fig.~\ref{fig:streamlifetime} shows average, 75p, and 25p of data liftime 
for each stream.
As shown in Fig.~\ref{fig:streamlifetime}, data lifetimes of stream 0 to 5
in \textsf{Manual} are gathered in a narrow range so data lifetime in
the same is quite similar.
However, data lifetime of streams in \textsf{AutoStream} shows relatively large difference
\textsf{AutoStream} does not notice when long-lived data is written to
the hot stream.
On the other hand, {\sf PCStream$^*$} can identify short-lived data from 
several dominant I/O activities as mentioned 
in section 2, for example, stream 0 and 1 in the Fig.~\ref{fig:streamlifetime}.
\textsf{PCStream} can further separate long-lived data of several streams 
(e.g., stream 3 and 4)
by moving their data to substreams (e.g., stream 5 and 6, respectively). 

\vspace{-10pt}
\subsection{Experiments with a real-world SSD}
%\vspace{-5pt}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\linewidth]{figure/result_ssd}
	\vspace{-10pt}
	\caption{A comparison of WAF on PM963.}
	\label{fig:result_SSD}
	\vspace{-15pt}
\end{figure}

In order to confirm the feasibility of \textsf{PCStream}, we also have
conducted experiments using Samsung's PM963 480GB SSD that supports 8 streams.
Since it was impossible to implement the two-phase stream assignment in the
commercial SSD firmware, we evaluated {\sf PCStream$^*$} only.  To warm up the
SSD before running benchmarks, we filled up 90\% of the SSD capacity with valid
data.

As illustrated in Fig.~\ref{fig:result_SSD}, {\sf PCStream$^*$} reduced WAF by
30\% over \textsf{AutoStream} on average.  There were large WAF gaps between
\textsf{PCStream$^{*}$} and the manually optimized case.  If the substream was
properly supported during GC, we believe that \textsf{PCStream} could show
similar WAF values as \textsf{Manual}.  \textsf{PCStream$^*$} still
outperformed \textsf{AutoStream}, but a performance gap was smaller over that
in the emulated SSD environment.  It was difficult to pinpoint why
\textsf{AutoStream} worked better in PM963 over in the emulated SSD, but we
suspect that some internal features of PM963 such as a large block size or some
implementation details of streams might be related. 

